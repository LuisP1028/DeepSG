<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Batch Gradient Descent</title>
    <style>
        :root {
            --bg-color: #000000;
            --fg-color: #00FF00;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: var(--fg-color);
            user-select: none; /* Prevent text highlighting while dragging */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab; /* distinct cursor for interaction */
            image-rendering: pixelated;
        }

        canvas:active {
            cursor: grabbing;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px var(--fg-color);
            z-index: 10;
        }

        .stat-line {
            margin-bottom: 5px;
            font-size: 14px;
            background-color: #000;
            padding: 2px 5px;
        }
        
        .hint-text {
            color: #88FF88;
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-line" id="status-text">SYSTEM: INITIALIZING...</div>
        <div class="stat-line" id="epoch-text">EPOCH: 0</div>
        <div class="stat-line" id="loss-text">LOSS: 0.0000</div>
        <div class="stat-line" id="grad-text">GRADIENT_ACC: 0%</div>
        <div class="stat-line hint-text">>> DRAG MOUSE TO ROTATE VIEW <<</div>
    </div>

    <canvas id="mainCanvas"></canvas>

<script>
/**
 * INTERACTIVE BATCH GRADIENT DESCENT
 * Style: Ditherpunk (Atkinson Dithering)
 */

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// UI Elements
const uiStatus = document.getElementById('status-text');
const uiEpoch = document.getElementById('epoch-text');
const uiLoss = document.getElementById('loss-text');
const uiGrad = document.getElementById('grad-text');

// CONFIGURATION
const INTERNAL_WIDTH = 320; 
let INTERNAL_HEIGHT = 180;  
const COLOR_ON = [0, 255, 0];   
const COLOR_OFF = [20, 20, 20]; 

// INTERACTION STATE (Camera)
let camState = {
    angleY: Math.PI / 4, // Initial horizontal rotation
    angleX: 0.5,         // Initial vertical tilt
    isDragging: false,
    lastMouseX: 0,
    lastMouseY: 0
};

// SIMULATION STATE
let simState = {
    epoch: 0,
    memoryBuffer: 0, 
    phase: 'SCANNING', 
    theta: { x: 2.5, z: 2.5 }, 
    targetTheta: { x: 2.5, z: 2.5 },
    learningRate: 0.2,
    scanSpeed: 1.5, 
    flashIntensity: 0
};

let bufferCanvas = document.createElement('canvas');
let bctx = bufferCanvas.getContext('2d');

function resize() {
    const aspect = window.innerWidth / window.innerHeight;
    INTERNAL_HEIGHT = Math.floor(INTERNAL_WIDTH / aspect);
    bufferCanvas.width = INTERNAL_WIDTH;
    bufferCanvas.height = INTERNAL_HEIGHT;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageRendering = 'pixelated';
}
window.addEventListener('resize', resize);
resize();

// --- INPUT HANDLING (ROTATION) ---
canvas.addEventListener('mousedown', (e) => {
    camState.isDragging = true;
    camState.lastMouseX = e.clientX;
    camState.lastMouseY = e.clientY;
});

window.addEventListener('mouseup', () => {
    camState.isDragging = false;
});

window.addEventListener('mousemove', (e) => {
    if (!camState.isDragging) return;

    const deltaX = e.clientX - camState.lastMouseX;
    const deltaY = e.clientY - camState.lastMouseY;

    // Adjust angles based on mouse movement
    camState.angleY += deltaX * 0.01;
    camState.angleX += deltaY * 0.01;

    // Clamp vertical tilt to prevent flipping upside down
    camState.angleX = Math.max(0.1, Math.min(Math.PI / 2, camState.angleX));

    camState.lastMouseX = e.clientX;
    camState.lastMouseY = e.clientY;
});

// --- 3D MATH HELPERS ---
function project3D(x, y, z, cx, cy, scale) {
    // Use dynamic camera angles
    const ay = camState.angleY;
    const ax = camState.angleX;

    // Rotate around Y axis (Horizontal spin)
    const rx = x * Math.cos(ay) - z * Math.sin(ay);
    const rz = x * Math.sin(ay) + z * Math.cos(ay);
    
    // Rotate around X axis (Vertical tilt)
    // We project 3D coords onto 2D plane:
    // Screen X comes from rotated X
    // Screen Y comes from rotated Y and Z (perspective tilt)
    const screenX = rx;
    const screenY = y * Math.cos(ax) - rz * Math.sin(ax);
    
    return {
        x: cx + screenX * scale,
        y: cy - screenY * scale 
    };
}

function getCost(x, z) {
    return (x * x + z * z) * 0.15;
}

// --- DRAWING FUNCTIONS ---

function drawLandscape(ctx, width, height) {
    const cx = width * 0.25; 
    const cy = height * 0.55; 
    const scale = 20;
    const range = 3.5;

    ctx.strokeStyle = '#FFFFFF'; 
    ctx.lineWidth = 1;

    // Draw Grid Lines along X
    for (let x = -range; x <= range; x += 0.5) {
        ctx.beginPath();
        for (let z = -range; z <= range; z += 0.5) {
            let y = getCost(x, z);
            let p = project3D(x, y, z, cx, cy, scale);
            if (z === -range) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }
    
    // Draw Grid Lines along Z
    for (let z = -range; z <= range; z += 0.5) {
        ctx.beginPath();
        for (let x = -range; x <= range; x += 0.5) {
            let y = getCost(x, z);
            let p = project3D(x, y, z, cx, cy, scale);
            if (x === -range) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }

    // Interpolate ball position
    const renderX = simState.theta.x + (simState.targetTheta.x - simState.theta.x) * 0.2;
    const renderZ = simState.theta.z + (simState.targetTheta.z - simState.theta.z) * 0.2;
    simState.theta.x = renderX;
    simState.theta.z = renderZ;

    const cost = getCost(renderX, renderZ);
    const ballPos = project3D(renderX, cost, renderZ, cx, cy, scale);

    // Shadow
    const shadowPos = project3D(renderX, -1, renderZ, cx, cy, scale);
    ctx.fillStyle = '#444';
    ctx.fillRect(shadowPos.x - 2, shadowPos.y - 1, 4, 2);

    // Ball
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(ballPos.x, ballPos.y, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Gradient Vector
    if (simState.phase === 'UPDATING' || simState.flashIntensity > 0) {
        ctx.strokeStyle = '#FFF';
        ctx.beginPath();
        ctx.moveTo(ballPos.x, ballPos.y);
        
        // Calculate gradient direction visually
        // Gradient of x^2 + z^2 is vector [2x, 2z]
        // We point opposite to gradient (descent) -> [-x, -z]
        // We project a point slightly "downhill"
        const gradX = renderX - (renderX * 0.5); 
        const gradZ = renderZ - (renderZ * 0.5);
        const gradY = getCost(gradX, gradZ); // Height at that point
        
        const nextPos = project3D(gradX, gradY, gradZ, cx, cy, scale); 
        
        ctx.lineTo(nextPos.x, nextPos.y);
        ctx.stroke();
    }
}

function drawDataGrid(ctx, width, height) {
    const startX = width * 0.55;
    const startY = height * 0.15;
    const w = width * 0.4;
    const h = height * 0.7;
    
    const cols = 10;
    const rows = 15;
    const cellW = w / cols;
    const cellH = h / rows;
    const totalCells = cols * rows;
    
    const cellsFilled = Math.floor((simState.memoryBuffer / 100) * totalCells);

    ctx.lineWidth = 1;

    for (let i = 0; i < totalCells; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * cellW;
        const y = startY + row * cellH;
        const g = 1; 

        if (i < cellsFilled) {
            ctx.fillStyle = '#AAA'; 
            ctx.fillRect(x + g, y + g, cellW - g*2, cellH - g*2);
        } else {
            ctx.strokeStyle = '#555'; 
            ctx.strokeRect(x + g, y + g, cellW - g*2, cellH - g*2);
        }
    }

    ctx.strokeStyle = '#FFF';
    ctx.strokeRect(startX, startY + h + 10, w, 5);
    ctx.fillStyle = '#FFF';
    ctx.fillRect(startX, startY + h + 10, w * (simState.memoryBuffer/100), 5);
}

// --- ATKINSON DITHERING ---
function applyDithering(imageData) {
    const w = imageData.width;
    const h = imageData.height;
    const d = imageData.data;

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const i = (y * w + x) * 4;
            const oldPixel = d[i+1]; 
            const newPixel = oldPixel > 100 ? 255 : 0;
            const quantError = oldPixel - newPixel;
            
            if (newPixel === 255) {
                d[i] = COLOR_ON[0];
                d[i+1] = COLOR_ON[1];
                d[i+2] = COLOR_ON[2];
            } else {
                d[i] = COLOR_OFF[0];
                d[i+1] = COLOR_OFF[1];
                d[i+2] = COLOR_OFF[2];
            }
            d[i+3] = 255;

            if (x + 1 < w)           d[((y) * w + (x + 1)) * 4 + 1] += quantError >> 3;
            if (x + 2 < w)           d[((y) * w + (x + 2)) * 4 + 1] += quantError >> 3;
            if (y + 1 < h && x > 0)  d[((y + 1) * w + (x - 1)) * 4 + 1] += quantError >> 3;
            if (y + 1 < h)           d[((y + 1) * w + (x)) * 4 + 1] += quantError >> 3;
            if (y + 1 < h && x + 1 < w) d[((y + 1) * w + (x + 1)) * 4 + 1] += quantError >> 3;
            if (y + 2 < h)           d[((y + 2) * w + (x)) * 4 + 1] += quantError >> 3;
        }
    }
    return imageData;
}

// --- MAIN LOOP ---

function logic() {
    if (simState.phase === 'SCANNING') {
        uiStatus.innerText = "SYSTEM: ACCUMULATING GRADIENT (BATCH MODE)";
        simState.memoryBuffer += simState.scanSpeed;
        
        if (simState.memoryBuffer >= 100) {
            simState.memoryBuffer = 100;
            simState.phase = 'CALCULATING';
            setTimeout(() => { simState.phase = 'UPDATING'; }, 500); 
        }
    }
    else if (simState.phase === 'CALCULATING') {
        uiStatus.innerText = "SYSTEM: AVERAGING GRADIENTS...";
    }
    else if (simState.phase === 'UPDATING') {
        uiStatus.innerText = "SYSTEM: UPDATING PARAMETERS";
        
        simState.targetTheta.x -= simState.targetTheta.x * simState.learningRate;
        simState.targetTheta.z -= simState.targetTheta.z * simState.learningRate;
        
        simState.epoch++;
        simState.flashIntensity = 20; 
        
        simState.memoryBuffer = 0;
        simState.phase = 'SCANNING';
    }

    if (simState.flashIntensity > 0) simState.flashIntensity--;
}

function draw() {
    bctx.fillStyle = '#000';
    bctx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);

    bctx.strokeStyle = '#555';
    bctx.beginPath();
    bctx.moveTo(bufferCanvas.width / 2, 0);
    bctx.lineTo(bufferCanvas.width / 2, bufferCanvas.height);
    bctx.stroke();

    drawLandscape(bctx, bufferCanvas.width, bufferCanvas.height);
    drawDataGrid(bctx, bufferCanvas.width, bufferCanvas.height);

    if (simState.flashIntensity > 0) {
        bctx.fillStyle = `rgba(255, 255, 255, ${simState.flashIntensity / 40})`;
        bctx.fillRect(0,0, bufferCanvas.width, bufferCanvas.height);
    }

    let imageData = bctx.getImageData(0, 0, bufferCanvas.width, bufferCanvas.height);
    imageData = applyDithering(imageData);
    bctx.putImageData(imageData, 0, 0);

    ctx.drawImage(bufferCanvas, 0, 0, canvas.width, canvas.height);

    uiGrad.innerText = `BUFFER_FILL: [${"|".repeat(Math.floor(simState.memoryBuffer/10))}${".".repeat(10 - Math.floor(simState.memoryBuffer/10))}] ${Math.floor(simState.memoryBuffer)}%`;
    uiLoss.innerText = `LOSS: ${getCost(simState.theta.x, simState.theta.z).toFixed(4)}`;
    uiEpoch.innerText = `EPOCH: ${simState.epoch}`;
}

function loop() {
    logic();
    draw();
    requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>