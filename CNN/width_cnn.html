<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Width Based CNN</title>
    <style>
        body { background: #000; color: #00FF41; font-family: 'VT323', monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        header { padding: 20px; border-bottom: 1px solid #00FF41; display: flex; justify-content: space-between; }
        #canvas-wrap { flex: 1; position: relative; }
        canvas { width: 100%; height: 100%; }
        input[type=range] { width: 300px; }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>WIDTH / CHANNEL CAPACITY</h1>
            <div id="info">CHANNELS: 4 (LOW DETAIL)</div>
        </div>
        <input type="range" id="width-slider" min="4" max="64" step="4" value="4">
    </header>
    <div id="canvas-wrap">
        <canvas id="c"></canvas>
    </div>

<script>
    const c = document.getElementById('c');
    const ctx = c.getContext('2d');
    const slider = document.getElementById('width-slider');
    const info = document.getElementById('info');
    
    let channels = 4;
    slider.oninput = (e) => {
        channels = parseInt(e.target.value);
        info.innerText = `CHANNELS: ${channels} (${channels > 32 ? "HIGH FIDELITY" : "LOW FIDELITY"})`;
    };

    let w, h;
    function resize() { w = c.width = c.offsetWidth; h = c.height = c.offsetHeight; }
    window.addEventListener('resize', resize);
    resize();

    function drawPattern(x, y, s, seed) {
        ctx.strokeStyle = '#00FF41';
        ctx.strokeRect(x, y, s, s);
        ctx.beginPath();
        // Generative patterns based on seed index
        switch(seed % 4) {
            case 0: // Horizontal
                for(let i=0; i<s; i+=4) { ctx.moveTo(x, y+i); ctx.lineTo(x+s, y+i); }
                break;
            case 1: // Vertical
                for(let i=0; i<s; i+=4) { ctx.moveTo(x+i, y); ctx.lineTo(x+i, y+s); }
                break;
            case 2: // Diagonal
                ctx.moveTo(x, y); ctx.lineTo(x+s, y+s);
                ctx.moveTo(x+s, y); ctx.lineTo(x, y+s);
                break;
            case 3: // Noise
                for(let i=0; i<20; i++) ctx.rect(x+Math.random()*s, y+Math.random()*s, 1, 1);
                break;
        }
        ctx.stroke();
    }

    function loop() {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);

        // 1. Draw The "Cube" (Layer Representation)
        const cx = w * 0.3;
        const cy = h * 0.5;
        const size = 100;
        const depth = channels * 4; // Visual depth based on slider

        ctx.strokeStyle = '#00FF41';
        ctx.lineWidth = 2;

        // Back face
        ctx.setLineDash([2, 4]);
        ctx.strokeRect(cx - size/2 + depth, cy - size/2 - depth/2, size, size);
        
        // Connecting lines
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(cx - size/2, cy - size/2); // Top Left Front
        ctx.lineTo(cx - size/2 + depth, cy - size/2 - depth/2); // Top Left Back
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cx + size/2, cy + size/2); // Bot Right Front
        ctx.lineTo(cx + size/2 + depth, cy + size/2 - depth/2); // Bot Right Back
        ctx.stroke();

        // Front Face
        ctx.fillStyle = '#000';
        ctx.fillRect(cx - size/2, cy - size/2, size, size);
        ctx.strokeRect(cx - size/2, cy - size/2, size, size);

        // 2. Draw The Feature Grid (Breakout view)
        const gridX = w * 0.6;
        const gridY = h * 0.2;
        const cols = 8;
        const cellSize = 30;
        
        ctx.fillStyle = '#00FF41';
        ctx.fillText("LEARNED FEATURES:", gridX, gridY - 20);

        for(let i=0; i<channels; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            drawPattern(gridX + col * (cellSize+5), gridY + row * (cellSize+5), cellSize, i);
        }

        requestAnimationFrame(loop);
    }
    loop();
</script>
</body>
</html>